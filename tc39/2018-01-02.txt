{"nick":"AtumT","reason":"Remote host closed the connection","date":"2018-01-02T01:03:56.193Z","type":"quit"}
{"nick":"ljharb","message":"works well for me too. i'd still also like a keyword to refer to the current class (something far more common than recursion ime) but that could still happen later.","date":"2018-01-02T01:30:23.945Z","type":"message"}
{"nick":"jwalden","reason":"Ping timeout: 252 seconds","date":"2018-01-02T02:36:13.863Z","type":"quit"}
{"nick":"jmdyck","reason":"Remote host closed the connection","date":"2018-01-02T05:23:03.371Z","type":"quit"}
{"nick":"howdoi","date":"2018-01-02T05:39:54.724Z","type":"join"}
{"nick":"floatleft","reason":"Ping timeout: 256 seconds","date":"2018-01-02T06:11:17.567Z","type":"quit"}
{"nick":"floatleft","date":"2018-01-02T06:12:40.562Z","type":"join"}
{"nick":"floatleft","reason":"Ping timeout: 256 seconds","date":"2018-01-02T06:57:45.583Z","type":"quit"}
{"nick":"floatleft","date":"2018-01-02T06:58:29.184Z","type":"join"}
{"nick":"Domenic","message":"Bakkot: why does your version work on a subclass","date":"2018-01-02T07:22:17.388Z","type":"message"}
{"nick":"Bakkot","message":"'cause it just uses a closed-over function","date":"2018-01-02T07:22:33.086Z","type":"message"}
{"nick":"Bakkot","message":"no typechecks in sight","date":"2018-01-02T07:22:53.045Z","type":"message"}
{"nick":"Domenic","message":"The typechecks occur when you try to do subclass.#privateField = foo inside the method though","date":"2018-01-02T07:23:08.880Z","type":"message"}
{"nick":"Domenic","message":"But both of our versions don't use the subclass constructor, they always use `new JSDOM()`","date":"2018-01-02T07:23:41.236Z","type":"message"}
{"nick":"Domenic","message":"So I don't see why typechecks would occur in my version either","date":"2018-01-02T07:23:53.279Z","type":"message"}
{"nick":"Bakkot","message":"You're right that your version works (see edit), but only because you wrote `JSDOM.#finalize` rather than (as I expect people to write) `this.#finalize`","date":"2018-01-02T07:24:32.893Z","type":"message"}
{"nick":"Bakkot","message":"(also I'm currently running a 102Â° fever, so it is very possibly I am just wrong about things)","date":"2018-01-02T07:25:11.997Z","type":"message"}
{"nick":"Bakkot","message":"(kind of tempted to suggest we ban _only_ `this.#foo` where `#foo` is a static private field. or at least have the babel plugin give a warning for that? do babel plugins give warnings)","date":"2018-01-02T07:27:57.704Z","type":"message"}
{"nick":"Domenic","message":"Yeah I was kinda thinking that too","date":"2018-01-02T07:30:57.725Z","type":"message"}
{"nick":"Domenic","message":"It kind of aligns with the idea of this being sugar over lexical declarations","date":"2018-01-02T07:31:12.646Z","type":"message"}
{"nick":"Domenic","message":"We could say that `#foo` is always a reference to the static private `#foo`. Whereas you need to qualify with `x.#foo` or `this.#foo` for instance private.","date":"2018-01-02T07:31:58.182Z","type":"message"}
{"nick":"Domenic","message":"And you can't use dot access to touch static private at all?","date":"2018-01-02T07:32:10.623Z","type":"message"}
{"nick":"Bakkot","message":"Hm. That's a little awkward - it's weird to have only one of the four forms be different: `class A { ix = 0; #iy = 1; static sx = 2; static #sy = 3; m(){ return this.ix + this.#iy + A.sx + #sy } }`","date":"2018-01-02T07:35:01.640Z","type":"message"}
{"nick":"Domenic","message":"True","date":"2018-01-02T07:35:48.180Z","type":"message"}
{"nick":"Bakkot","message":"this is a hard thing to reason about abstractly. maybe we pick a semantics and leave it at stage 2 for a while and see what people's experience of it is via Babel?","date":"2018-01-02T07:37:34.244Z","type":"message"}
{"nick":"Bakkot","message":"if in fact it ends up being rare to write `this.#staticMethod` instead of `className.#staticMethod`, I'm a lot more comfortable going forward with the old semantics (i.e. the one where it breaks on subclasses).","date":"2018-01-02T07:38:38.401Z","type":"message"}
{"nick":"Domenic","message":"Seems reasonable. I think most people do not in general use `this` inside their static methods","date":"2018-01-02T07:39:09.708Z","type":"message"}
{"nick":"Domenic","message":"That might be quantifiable today","date":"2018-01-02T07:39:17.205Z","type":"message"}
{"nick":"ljharb","message":"they'd face the same hazard doing so with public properties","date":"2018-01-02T07:39:52.296Z","type":"message"}
{"nick":"Bakkot","message":"ljharb, expand?","date":"2018-01-02T07:40:06.173Z","type":"message"}
{"nick":"ljharb","message":"so i suspect there's already a lot of inertia against using `this` inside static methods","date":"2018-01-02T07:40:08.065Z","type":"message"}
{"nick":"ljharb","message":"it's only with `class extends` that subclass constructors inherit from the superclass constructor","date":"2018-01-02T07:40:30.532Z","type":"message"}
{"nick":"ljharb","message":"ie, with `class extends` there's no hazard, but with all pre-ES6 inheritance, there is one","date":"2018-01-02T07:40:46.336Z","type":"message"}
{"nick":"ljharb","message":"so i doubt it's very common","date":"2018-01-02T07:40:51.779Z","type":"message"}
{"nick":"Bakkot","message":"oh. it has not been my impression that most people carried over their pre-ES6 habits to ES6 classes, though I could be wrong.","date":"2018-01-02T07:41:20.731Z","type":"message"}
{"nick":"ljharb","message":"fair","date":"2018-01-02T07:41:28.940Z","type":"message"}
{"nick":"ljharb","message":"i dunno tho, i think using `this` in a static method is just super weird","date":"2018-01-02T07:41:41.908Z","type":"message"}
{"nick":"Domenic","message":"I think the assertion is that people didn't bother to create new habits for calling static methods when they moved to ES6 classes","date":"2018-01-02T07:41:43.647Z","type":"message"}
{"nick":"ljharb","message":"^ yes, that","date":"2018-01-02T07:41:50.446Z","type":"message"}
{"nick":"ljharb","message":"since dan's suggestion allows for domenic's use case, without imo creating a new hazard, and also leaves open possibilities for future improvements, i think it sounds great","date":"2018-01-02T07:42:32.055Z","type":"message"}
{"nick":"Bakkot","message":"Definitely creates a new hazard, though it might turn out to be one people rarely trip over.","date":"2018-01-02T07:43:09.408Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: you've previously suggested that repeating the class name is a bad thing, so I'm a little surprised you find `this` in static methods weird","date":"2018-01-02T07:45:19.286Z","type":"message"}
{"nick":"ljharb","message":"well, it restores a pre-ES6 hazard","date":"2018-01-02T07:45:22.245Z","type":"message"}
{"nick":"ljharb","message":"i think repeating the class name is bad, but `this` is invocation-determined, so that'd be worse","date":"2018-01-02T07:45:36.695Z","type":"message"}
{"nick":"ljharb","message":"repeating the class name is currently the only robust means of referencing the constructor from a static method","date":"2018-01-02T07:46:02.518Z","type":"message"}
{"nick":"Bakkot","message":"I often _want_ things to be invocation-determined: that's the whole point of dynamic dispatch","date":"2018-01-02T07:46:31.368Z","type":"message"}
{"nick":"Bakkot","message":"if I am exposing a class and expecting people to extend it, I may well be intending to allow them to overwrite some of the behavior of the class","date":"2018-01-02T07:47:00.871Z","type":"message"}
{"nick":"Bakkot","message":"it's more common to do this by overwriting non-static methods, sure, but there's nothing in principle different about static methods here.","date":"2018-01-02T07:47:31.660Z","type":"message"}
{"nick":"ljharb","message":"sure, and if you want that, you'd use `this`","date":"2018-01-02T07:50:58.650Z","type":"message"}
{"nick":"Bakkot","message":"and then you'd run into the hazard with subclasses and static private.","date":"2018-01-02T07:51:47.826Z","type":"message"}
{"nick":"Bakkot","message":"hmmmmm","date":"2018-01-02T07:51:57.859Z","type":"message"}
{"nick":"ljharb","message":"sure. but Domenic's use case was for base class static private","date":"2018-01-02T07:52:02.745Z","type":"message"}
{"nick":"ljharb","message":"has anyone come up with a noncontrived one for inherited static private?","date":"2018-01-02T07:52:16.016Z","type":"message"}
{"nick":"Bakkot","message":"right; that use case is met, but I worry that in allowing it by this proposed semantics we introduce a footgun.","date":"2018-01-02T07:52:27.466Z","type":"message"}
{"nick":"Bakkot","message":"Domenic: you don't have a usecase for static private *fields*, do you?","date":"2018-01-02T07:52:30.532Z","type":"message"}
{"nick":"ljharb","message":"like where you'd do `this.#foo` in a static method and expect it to do something useful for subclasses?","date":"2018-01-02T07:52:31.282Z","type":"message"}
{"nick":"Bakkot","message":"yet another possible resolution occurs to me, one I'm maybe actually happy with:","date":"2018-01-02T07:52:51.172Z","type":"message"}
{"nick":"Bakkot","message":"a.) no static private fields; prefer closing over variables. b.) static private methods, and *only* static private methods, are copied to subclasses at initialization time.","date":"2018-01-02T07:53:38.936Z","type":"message"}
{"nick":"Bakkot","message":"er, at subclass definition time, rather.","date":"2018-01-02T07:53:53.712Z","type":"message"}
{"nick":"Bakkot","message":"b.) is similar to my earlier \"reinitialize static fields on subclasses\" thing, except that it doesn't have the issue of unexpectedly running code twice: private methods, static or otherwise, do not run code during initialization and are not mutable.","date":"2018-01-02T07:54:56.220Z","type":"message"}
{"nick":"Domenic","message":"Fields I'd just like so I can logically group my code in the class body","date":"2018-01-02T07:55:49.926Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: and you'd be fine with static publics as-is, and you think everybody would be ok with the difference?","date":"2018-01-02T07:56:12.278Z","type":"message"}
{"nick":"Domenic","message":"I really don't think subclasses are worth worrying about or building mechanisms to serve, myself.","date":"2018-01-02T07:56:19.660Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: yeah, pretty much. I actually don't think anyone would notice the difference, except in noticing there are no static private fields.","date":"2018-01-02T07:56:48.375Z","type":"message"}
{"nick":"ljharb","message":"and it'd not be ok to have static private fields (that throw on subclass.#foo), and then also have static private methods as you indicated?","date":"2018-01-02T07:57:34.056Z","type":"message"}
{"nick":"Bakkot","message":"um. I guess I'd be ok with that too, but then people would definitely notice the difference: it would be weird if `static #m(){ return 0; }` didn't throw, but `static #m = () => 0` did.","date":"2018-01-02T07:58:37.622Z","type":"message"}
{"nick":"ljharb","message":"yeah true","date":"2018-01-02T07:58:43.959Z","type":"message"}
{"nick":"ljharb","message":"arrow functions in fields is gross tho imo :-/ the airbnb config will be forbidding that one for sure","date":"2018-01-02T07:59:02.729Z","type":"message"}
{"nick":"ljharb","message":"but yeah that would be a weird inconsistency","date":"2018-01-02T07:59:11.885Z","type":"message"}
{"nick":"Bakkot","message":"Domenic: I do. I use subclasses a fair bit, actually, if I'm using classes at all.","date":"2018-01-02T07:59:20.645Z","type":"message"}
