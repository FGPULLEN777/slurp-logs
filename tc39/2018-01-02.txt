{"nick":"AtumT","reason":"Remote host closed the connection","date":"2018-01-02T01:03:56.193Z","type":"quit"}
{"nick":"ljharb","message":"works well for me too. i'd still also like a keyword to refer to the current class (something far more common than recursion ime) but that could still happen later.","date":"2018-01-02T01:30:23.945Z","type":"message"}
{"nick":"jwalden","reason":"Ping timeout: 252 seconds","date":"2018-01-02T02:36:13.863Z","type":"quit"}
{"nick":"jmdyck","reason":"Remote host closed the connection","date":"2018-01-02T05:23:03.371Z","type":"quit"}
{"nick":"howdoi","date":"2018-01-02T05:39:54.724Z","type":"join"}
{"nick":"floatleft","reason":"Ping timeout: 256 seconds","date":"2018-01-02T06:11:17.567Z","type":"quit"}
{"nick":"floatleft","date":"2018-01-02T06:12:40.562Z","type":"join"}
{"nick":"floatleft","reason":"Ping timeout: 256 seconds","date":"2018-01-02T06:57:45.583Z","type":"quit"}
{"nick":"floatleft","date":"2018-01-02T06:58:29.184Z","type":"join"}
{"nick":"Domenic","message":"Bakkot: why does your version work on a subclass","date":"2018-01-02T07:22:17.388Z","type":"message"}
{"nick":"Bakkot","message":"'cause it just uses a closed-over function","date":"2018-01-02T07:22:33.086Z","type":"message"}
{"nick":"Bakkot","message":"no typechecks in sight","date":"2018-01-02T07:22:53.045Z","type":"message"}
{"nick":"Domenic","message":"The typechecks occur when you try to do subclass.#privateField = foo inside the method though","date":"2018-01-02T07:23:08.880Z","type":"message"}
{"nick":"Domenic","message":"But both of our versions don't use the subclass constructor, they always use `new JSDOM()`","date":"2018-01-02T07:23:41.236Z","type":"message"}
{"nick":"Domenic","message":"So I don't see why typechecks would occur in my version either","date":"2018-01-02T07:23:53.279Z","type":"message"}
{"nick":"Bakkot","message":"You're right that your version works (see edit), but only because you wrote `JSDOM.#finalize` rather than (as I expect people to write) `this.#finalize`","date":"2018-01-02T07:24:32.893Z","type":"message"}
{"nick":"Bakkot","message":"(also I'm currently running a 102Â° fever, so it is very possibly I am just wrong about things)","date":"2018-01-02T07:25:11.997Z","type":"message"}
{"nick":"Bakkot","message":"(kind of tempted to suggest we ban _only_ `this.#foo` where `#foo` is a static private field. or at least have the babel plugin give a warning for that? do babel plugins give warnings)","date":"2018-01-02T07:27:57.704Z","type":"message"}
{"nick":"Domenic","message":"Yeah I was kinda thinking that too","date":"2018-01-02T07:30:57.725Z","type":"message"}
{"nick":"Domenic","message":"It kind of aligns with the idea of this being sugar over lexical declarations","date":"2018-01-02T07:31:12.646Z","type":"message"}
{"nick":"Domenic","message":"We could say that `#foo` is always a reference to the static private `#foo`. Whereas you need to qualify with `x.#foo` or `this.#foo` for instance private.","date":"2018-01-02T07:31:58.182Z","type":"message"}
{"nick":"Domenic","message":"And you can't use dot access to touch static private at all?","date":"2018-01-02T07:32:10.623Z","type":"message"}
{"nick":"Bakkot","message":"Hm. That's a little awkward - it's weird to have only one of the four forms be different: `class A { ix = 0; #iy = 1; static sx = 2; static #sy = 3; m(){ return this.ix + this.#iy + A.sx + #sy } }`","date":"2018-01-02T07:35:01.640Z","type":"message"}
{"nick":"Domenic","message":"True","date":"2018-01-02T07:35:48.180Z","type":"message"}
{"nick":"Bakkot","message":"this is a hard thing to reason about abstractly. maybe we pick a semantics and leave it at stage 2 for a while and see what people's experience of it is via Babel?","date":"2018-01-02T07:37:34.244Z","type":"message"}
{"nick":"Bakkot","message":"if in fact it ends up being rare to write `this.#staticMethod` instead of `className.#staticMethod`, I'm a lot more comfortable going forward with the old semantics (i.e. the one where it breaks on subclasses).","date":"2018-01-02T07:38:38.401Z","type":"message"}
{"nick":"Domenic","message":"Seems reasonable. I think most people do not in general use `this` inside their static methods","date":"2018-01-02T07:39:09.708Z","type":"message"}
{"nick":"Domenic","message":"That might be quantifiable today","date":"2018-01-02T07:39:17.205Z","type":"message"}
{"nick":"ljharb","message":"they'd face the same hazard doing so with public properties","date":"2018-01-02T07:39:52.296Z","type":"message"}
{"nick":"Bakkot","message":"ljharb, expand?","date":"2018-01-02T07:40:06.173Z","type":"message"}
{"nick":"ljharb","message":"so i suspect there's already a lot of inertia against using `this` inside static methods","date":"2018-01-02T07:40:08.065Z","type":"message"}
{"nick":"ljharb","message":"it's only with `class extends` that subclass constructors inherit from the superclass constructor","date":"2018-01-02T07:40:30.532Z","type":"message"}
{"nick":"ljharb","message":"ie, with `class extends` there's no hazard, but with all pre-ES6 inheritance, there is one","date":"2018-01-02T07:40:46.336Z","type":"message"}
{"nick":"ljharb","message":"so i doubt it's very common","date":"2018-01-02T07:40:51.779Z","type":"message"}
{"nick":"Bakkot","message":"oh. it has not been my impression that most people carried over their pre-ES6 habits to ES6 classes, though I could be wrong.","date":"2018-01-02T07:41:20.731Z","type":"message"}
{"nick":"ljharb","message":"fair","date":"2018-01-02T07:41:28.940Z","type":"message"}
{"nick":"ljharb","message":"i dunno tho, i think using `this` in a static method is just super weird","date":"2018-01-02T07:41:41.908Z","type":"message"}
{"nick":"Domenic","message":"I think the assertion is that people didn't bother to create new habits for calling static methods when they moved to ES6 classes","date":"2018-01-02T07:41:43.647Z","type":"message"}
{"nick":"ljharb","message":"^ yes, that","date":"2018-01-02T07:41:50.446Z","type":"message"}
{"nick":"ljharb","message":"since dan's suggestion allows for domenic's use case, without imo creating a new hazard, and also leaves open possibilities for future improvements, i think it sounds great","date":"2018-01-02T07:42:32.055Z","type":"message"}
{"nick":"Bakkot","message":"Definitely creates a new hazard, though it might turn out to be one people rarely trip over.","date":"2018-01-02T07:43:09.408Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: you've previously suggested that repeating the class name is a bad thing, so I'm a little surprised you find `this` in static methods weird","date":"2018-01-02T07:45:19.286Z","type":"message"}
{"nick":"ljharb","message":"well, it restores a pre-ES6 hazard","date":"2018-01-02T07:45:22.245Z","type":"message"}
{"nick":"ljharb","message":"i think repeating the class name is bad, but `this` is invocation-determined, so that'd be worse","date":"2018-01-02T07:45:36.695Z","type":"message"}
{"nick":"ljharb","message":"repeating the class name is currently the only robust means of referencing the constructor from a static method","date":"2018-01-02T07:46:02.518Z","type":"message"}
{"nick":"Bakkot","message":"I often _want_ things to be invocation-determined: that's the whole point of dynamic dispatch","date":"2018-01-02T07:46:31.368Z","type":"message"}
{"nick":"Bakkot","message":"if I am exposing a class and expecting people to extend it, I may well be intending to allow them to overwrite some of the behavior of the class","date":"2018-01-02T07:47:00.871Z","type":"message"}
{"nick":"Bakkot","message":"it's more common to do this by overwriting non-static methods, sure, but there's nothing in principle different about static methods here.","date":"2018-01-02T07:47:31.660Z","type":"message"}
{"nick":"ljharb","message":"sure, and if you want that, you'd use `this`","date":"2018-01-02T07:50:58.650Z","type":"message"}
{"nick":"Bakkot","message":"and then you'd run into the hazard with subclasses and static private.","date":"2018-01-02T07:51:47.826Z","type":"message"}
{"nick":"Bakkot","message":"hmmmmm","date":"2018-01-02T07:51:57.859Z","type":"message"}
{"nick":"ljharb","message":"sure. but Domenic's use case was for base class static private","date":"2018-01-02T07:52:02.745Z","type":"message"}
{"nick":"ljharb","message":"has anyone come up with a noncontrived one for inherited static private?","date":"2018-01-02T07:52:16.016Z","type":"message"}
{"nick":"Bakkot","message":"right; that use case is met, but I worry that in allowing it by this proposed semantics we introduce a footgun.","date":"2018-01-02T07:52:27.466Z","type":"message"}
{"nick":"Bakkot","message":"Domenic: you don't have a usecase for static private *fields*, do you?","date":"2018-01-02T07:52:30.532Z","type":"message"}
{"nick":"ljharb","message":"like where you'd do `this.#foo` in a static method and expect it to do something useful for subclasses?","date":"2018-01-02T07:52:31.282Z","type":"message"}
{"nick":"Bakkot","message":"yet another possible resolution occurs to me, one I'm maybe actually happy with:","date":"2018-01-02T07:52:51.172Z","type":"message"}
{"nick":"Bakkot","message":"a.) no static private fields; prefer closing over variables. b.) static private methods, and *only* static private methods, are copied to subclasses at initialization time.","date":"2018-01-02T07:53:38.936Z","type":"message"}
{"nick":"Bakkot","message":"er, at subclass definition time, rather.","date":"2018-01-02T07:53:53.712Z","type":"message"}
{"nick":"Bakkot","message":"b.) is similar to my earlier \"reinitialize static fields on subclasses\" thing, except that it doesn't have the issue of unexpectedly running code twice: private methods, static or otherwise, do not run code during initialization and are not mutable.","date":"2018-01-02T07:54:56.220Z","type":"message"}
{"nick":"Domenic","message":"Fields I'd just like so I can logically group my code in the class body","date":"2018-01-02T07:55:49.926Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: and you'd be fine with static publics as-is, and you think everybody would be ok with the difference?","date":"2018-01-02T07:56:12.278Z","type":"message"}
{"nick":"Domenic","message":"I really don't think subclasses are worth worrying about or building mechanisms to serve, myself.","date":"2018-01-02T07:56:19.660Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: yeah, pretty much. I actually don't think anyone would notice the difference, except in noticing there are no static private fields.","date":"2018-01-02T07:56:48.375Z","type":"message"}
{"nick":"ljharb","message":"and it'd not be ok to have static private fields (that throw on subclass.#foo), and then also have static private methods as you indicated?","date":"2018-01-02T07:57:34.056Z","type":"message"}
{"nick":"Bakkot","message":"um. I guess I'd be ok with that too, but then people would definitely notice the difference: it would be weird if `static #m(){ return 0; }` didn't throw, but `static #m = () => 0` did.","date":"2018-01-02T07:58:37.622Z","type":"message"}
{"nick":"ljharb","message":"yeah true","date":"2018-01-02T07:58:43.959Z","type":"message"}
{"nick":"ljharb","message":"arrow functions in fields is gross tho imo :-/ the airbnb config will be forbidding that one for sure","date":"2018-01-02T07:59:02.729Z","type":"message"}
{"nick":"ljharb","message":"but yeah that would be a weird inconsistency","date":"2018-01-02T07:59:11.885Z","type":"message"}
{"nick":"Bakkot","message":"Domenic: I do. I use subclasses a fair bit, actually, if I'm using classes at all.","date":"2018-01-02T07:59:20.645Z","type":"message"}
{"nick":"Domenic","message":"Ok, it'd be good to provide example code, as I have, where your extra mechanisms provide some advantage.","date":"2018-01-02T08:03:54.299Z","type":"message"}
{"nick":"Bakkot","message":"Sure, I'll try to write something coherent and real-world-ish when I am coherent again. The basic idea is just that it meets your use clase without running into https://github.com/tc39/proposal-class-fields/issues/43#issuecomment-328681487, though.","date":"2018-01-02T08:06:32.585Z","type":"message"}
{"nick":"Bakkot","message":"(or, well, the equivalent of that but for static methods instead of static fields.)","date":"2018-01-02T08:08:26.053Z","type":"message"}
{"nick":"not-an-aardvark","message":"Would it be possible to just have `this#foo` be semantically identical to `(current class)#foo` when used in a static method? The special case is unappealing, but it doesn't seem like it would cause any observable problems given that static fields couldn't be overridden by subclasses anyway.","date":"2018-01-02T09:06:11.241Z","type":"message"}
{"nick":"Bakkot","message":"I'd strongly prefer we not make `this` even more magical.","date":"2018-01-02T09:19:38.568Z","type":"message"}
{"nick":"not-an-aardvark","message":"On reconsideration, I agree. Thinking through a less magical variant: I think the reason I expect `this#foo` to work in static methods is because my conceptual model for `this#foo` is effectively the same as something like `this.foo`, aside from the fact that `#foo` is inaccessible outside of the class.","date":"2018-01-02T09:25:02.104Z","type":"message"}
{"nick":"not-an-aardvark","message":"`this.foo` works on subclasses because it does a prototype chain lookup. What would be the effect of doing a prototype chain lookup for private fields as well?","date":"2018-01-02T09:25:29.233Z","type":"message"}
{"nick":"not-an-aardvark","message":"i.e. the semantics of `this#foo` would be \"if any object on the prototype chain of `this` has the `#foo` field declared in this scope, return the value of that field, otherwise throw\"","date":"2018-01-02T09:28:35.575Z","type":"message"}
{"nick":"not-an-aardvark","message":"If I'm not mistaken, this would be equivalent to the current behavior except with static methods and cases where the prototype of an object is modified.","date":"2018-01-02T09:30:39.994Z","type":"message"}
{"nick":"not-an-aardvark","message":"(By the way, I've read a lot of the discussion on the proposal repo but have probably missed some as well; please feel free to link me to an issue if this has already been discussed somewhere.)","date":"2018-01-02T09:35:42.754Z","type":"message"}
{"nick":"AtumT","date":"2018-01-02T09:38:51.871Z","type":"join"}
{"nick":"Bakkot","message":"not-an-aardvark: I can try to find a previous discussion, but the gist of it is that most of the committee feels strongly that private fields ought not walk up the prototype chain. This is particularly true for private instance fields, but we'd ideally want consistent semantics for private statics.","date":"2018-01-02T09:44:48.263Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: IIRC you use public static fields a lot, or would like to; can I ask how you do or would like to refer to them?","date":"2018-01-02T09:45:13.044Z","type":"message"}
{"nick":"floatleft","reason":"Ping timeout: 260 seconds","date":"2018-01-02T10:55:56.183Z","type":"quit"}
{"nick":"mylesborins","reason":"Quit: farewell for now","date":"2018-01-02T11:25:11.184Z","type":"quit"}
{"nick":"mylesborins","date":"2018-01-02T11:25:41.776Z","type":"join"}
{"nick":"floatleft","date":"2018-01-02T11:58:48.541Z","type":"join"}
{"nick":"not-an-aardvark","reason":"Quit: Connection closed for inactivity","date":"2018-01-02T12:00:57.460Z","type":"quit"}
{"nick":"floatleft","reason":"Ping timeout: 252 seconds","date":"2018-01-02T12:03:26.480Z","type":"quit"}
{"nick":"jmdyck","date":"2018-01-02T13:06:35.180Z","type":"join"}
{"nick":"littledan","message":"\"a.) no static private fields; prefer closing over variables. b.) static private methods, and *only* static private methods, are copied to subclasses at initialization time.\" This alternative seems really reasonable to me. I expanded on it in the explainer","date":"2018-01-02T14:59:53.841Z","type":"message"}
{"nick":"littledan","message":"see https://github.com/tc39/proposal-static-class-features#install-private-static-methods-on-subclasses-omit-private-static-fields","date":"2018-01-02T15:00:13.411Z","type":"message"}
{"nick":"littledan","message":"you could justify the copying semantics by saying, this is the same as what private instance methods do--install themselves in everyplace that you would've gotten them through prototype chain access","date":"2018-01-02T15:01:23.761Z","type":"message"}
{"nick":"littledan","message":"due to the lack of private prototype chain access","date":"2018-01-02T15:01:38.112Z","type":"message"}
{"nick":"littledan","message":"I don't think my writeup there is the best edited thing; I'd be happy to replace it or link from it anything else you want to write, Bakkot","date":"2018-01-02T15:02:11.262Z","type":"message"}
{"nick":"littledan","message":"not-an-aardvark: See https://github.com/tc39/proposal-static-class-features#prototype-chain-walk-for-private-fields-and-methods for a summary of why I'm not proposing a private prototype chain walk","date":"2018-01-02T15:03:48.389Z","type":"message"}
{"nick":"littledan","message":"it'd be great if any of you who are interested would come to a VC meeting to discuss what we should do about static class features. Write me outside of this channel, and I'll send you a link to sign up on a Doodle.","date":"2018-01-02T15:04:39.109Z","type":"message"}
{"nick":"littledan","message":"Bakkot: Am I right from the above discussion that you're very concerned about the TypeError issue? Do you not find the arguments in https://github.com/tc39/proposal-static-class-features#static-private-access-on-subclasses convincing?","date":"2018-01-02T15:16:08.263Z","type":"message"}
{"nick":"bradleymeck","date":"2018-01-02T15:18:31.826Z","type":"join"}
{"nick":"littledan","message":"Domenic: On the other hand, would you be OK with the alternative Bakkot is proposing, of installing private static methods on subclasses and skipping static private fields? I get the ordering issue but it seems sort of like the weakest use case so far.","date":"2018-01-02T15:18:42.564Z","type":"message"}
