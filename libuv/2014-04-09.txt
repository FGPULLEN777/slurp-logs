{"nick":"ircretary","reason":"Remote host closed the connection","date":"2014-04-09T00:00:00.404Z","type":"quit"}
{"nick":"ircretary","date":"2014-04-09T00:00:08.296Z","type":"join"}
{"nick":"LeftWing","message":"trevnorris: I started on adding it to libuv at some point ... https://github.com/jclulow/libuv/compare/crosscall","date":"2014-04-09T00:00:41.701Z","type":"message"}
{"nick":"kenperkins","reason":"Quit: Computer has gone to sleep.","date":"2014-04-09T00:01:24.151Z","type":"quit"}
{"nick":"trevnorris","message":"ooh, nice.","date":"2014-04-09T00:01:29.583Z","type":"message"}
{"nick":"tumdedum","reason":"Ping timeout: 255 seconds","date":"2014-04-09T00:04:20.485Z","type":"quit"}
{"nick":"tumdedum","date":"2014-04-09T00:11:58.477Z","type":"join"}
{"nick":"paulfryzel","date":"2014-04-09T00:13:48.626Z","type":"join"}
{"nick":"seldo","reason":"Remote host closed the connection","date":"2014-04-09T00:14:09.688Z","type":"quit"}
{"nick":"seldo","date":"2014-04-09T00:14:48.475Z","type":"join"}
{"nick":"guybrush","reason":"Excess Flood","date":"2014-04-09T00:16:35.077Z","type":"quit"}
{"nick":"stephank","date":"2014-04-09T00:16:35.560Z","type":"join"}
{"nick":"guybrush","date":"2014-04-09T00:17:04.893Z","type":"join"}
{"nick":"paulfryzel","reason":"Ping timeout: 246 seconds","date":"2014-04-09T00:18:11.612Z","type":"quit"}
{"nick":"rossk","reason":"Ping timeout: 240 seconds","date":"2014-04-09T00:18:18.471Z","type":"quit"}
{"nick":"mikolalysenko","reason":"Ping timeout: 250 seconds","date":"2014-04-09T00:25:05.260Z","type":"quit"}
{"nick":"paulfryzel","date":"2014-04-09T00:26:56.215Z","type":"join"}
{"nick":"brunkle","reason":"Quit: brunkle","date":"2014-04-09T00:33:24.759Z","type":"quit"}
{"nick":"dap_","reason":"Quit: Leaving.","date":"2014-04-09T00:40:50.227Z","type":"quit"}
{"nick":"wolfeidau","date":"2014-04-09T00:40:59.883Z","type":"join"}
{"nick":"wolfeidau","reason":"Remote host closed the connection","date":"2014-04-09T00:41:07.874Z","type":"quit"}
{"nick":"seldo","reason":"Remote host closed the connection","date":"2014-04-09T00:42:55.067Z","type":"quit"}
{"nick":"benvie_","date":"2014-04-09T00:43:09.176Z","type":"join"}
{"nick":"seldo","date":"2014-04-09T00:43:33.514Z","type":"join"}
{"nick":"benvie","reason":"Ping timeout: 250 seconds","date":"2014-04-09T00:44:35.253Z","type":"quit"}
{"nick":"inolen","reason":"Quit: Leaving.","date":"2014-04-09T00:46:34.936Z","type":"quit"}
{"nick":"inolen","date":"2014-04-09T00:46:50.240Z","type":"join"}
{"nick":"calvinfo","reason":"Quit: Leaving.","date":"2014-04-09T00:48:16.723Z","type":"quit"}
{"nick":"calvinfo","date":"2014-04-09T00:49:58.193Z","type":"join"}
{"nick":"thlorenz","date":"2014-04-09T00:51:23.608Z","type":"join"}
{"nick":"mikolalysenko","date":"2014-04-09T00:51:58.508Z","type":"join"}
{"nick":"thlorenz","reason":"Remote host closed the connection","date":"2014-04-09T00:52:13.447Z","type":"quit"}
{"nick":"Dirkson","message":"Hey all. So if I send a large amount of data via tcp, uv will break up the data into many separate sections for me, and will hand those sections to me one at a time, in order, in my tcp callback. So on the first run of the callback, I can read the first couple bytes of data, see my overall size, see what my data will be... How do I pass this information on to further calls of my receivetcp function?","date":"2014-04-09T00:53:29.420Z","type":"message"}
{"nick":"kazupon","date":"2014-04-09T00:57:46.623Z","type":"join"}
{"nick":"tjfontaine","message":"Dirkson: so -- tcp is a reliable in order transmission of what it's given","date":"2014-04-09T01:03:53.486Z","type":"message"}
{"nick":"sblom","reason":"Read error: Connection reset by peer","date":"2014-04-09T01:04:13.813Z","type":"quit"}
{"nick":"tjfontaine","message":"it's not about what uv will or won't do","date":"2014-04-09T01:04:14.338Z","type":"message"}
{"nick":"thlorenz","date":"2014-04-09T01:04:49.968Z","type":"join"}
{"nick":"tjfontaine","message":"as far as sending lots of data -- http://linux.die.net/man/2/write","date":"2014-04-09T01:04:59.130Z","type":"message"}
{"nick":"tjfontaine","message":"describes what the semantics are, not really about what libuv will do","date":"2014-04-09T01:05:15.104Z","type":"message"}
{"nick":"tjfontaine","message":"and related to how tcp itself also works","date":"2014-04-09T01:05:20.486Z","type":"message"}
{"nick":"stephank","reason":"Ping timeout: 240 seconds","date":"2014-04-09T01:06:42.378Z","type":"quit"}
{"nick":"Qard","reason":"Ping timeout: 240 seconds","date":"2014-04-09T01:08:58.193Z","type":"quit"}
{"nick":"stephank","date":"2014-04-09T01:11:09.314Z","type":"join"}
{"nick":"Dirkson","message":"tjfontaine: Well, I might want to write the data, sure... But to know if I want to do that, I need to check the first few bytes of data I send.","date":"2014-04-09T01:14:54.627Z","type":"message"}
{"nick":"Dirkson","message":"tjfontaine: And once the second callback happens, I lose access to the first bit of data in a particular stream.","date":"2014-04-09T01:16:14.613Z","type":"message"}
{"nick":"nifoc","reason":"Quit: Quit","date":"2014-04-09T01:17:18.340Z","type":"quit"}
{"nick":"euoia","date":"2014-04-09T01:17:33.310Z","type":"join"}
{"nick":"brunkle","date":"2014-04-09T01:17:35.190Z","type":"join"}
{"nick":"Dirkson","message":"And even if I did write it, I'd want to write different data to different places... Which is really hard to do if I can't tell which bit of data a particular callback is intended to reference.","date":"2014-04-09T01:18:08.067Z","type":"message"}
{"nick":"cosnis","date":"2014-04-09T01:19:26.289Z","type":"join"}
{"nick":"calvinfo","reason":"Quit: Leaving.","date":"2014-04-09T01:22:48.981Z","type":"quit"}
{"nick":"bradleymeck","date":"2014-04-09T01:22:56.616Z","type":"join"}
{"nick":"cosnis","reason":"Quit: Textual IRC Client: www.textualapp.com","date":"2014-04-09T01:24:33.265Z","type":"quit"}
{"nick":"seldo","reason":"Remote host closed the connection","date":"2014-04-09T01:25:49.379Z","type":"quit"}
{"nick":"seldo","date":"2014-04-09T01:27:49.464Z","type":"join"}
{"nick":"seldo","reason":"Remote host closed the connection","date":"2014-04-09T01:27:59.870Z","type":"quit"}
{"nick":"nifoc","date":"2014-04-09T01:30:22.522Z","type":"join"}
{"nick":"brunkle","reason":"Quit: brunkle","date":"2014-04-09T01:35:40.374Z","type":"quit"}
{"nick":"euoia","reason":"Ping timeout: 240 seconds","date":"2014-04-09T01:38:18.181Z","type":"quit"}
{"nick":"daviddias","date":"2014-04-09T01:49:59.510Z","type":"join"}
{"nick":"calvinfo","date":"2014-04-09T01:53:18.725Z","type":"join"}
{"nick":"daviddias","reason":"Ping timeout: 246 seconds","date":"2014-04-09T01:54:26.569Z","type":"quit"}
{"nick":"Dirkson","message":"Am I expected to write a per-user state machine based on the incoming data?","date":"2014-04-09T01:55:03.649Z","type":"message"}
{"nick":"calvinfo","reason":"Ping timeout: 246 seconds","date":"2014-04-09T01:57:35.526Z","type":"quit"}
{"nick":"Orborde","message":"Dirkson is writing a network protocol that runs over TCP. He wants to know how he is supposed to do the stateful bookkeeping involved in parsing protocol messages that are going to arrive over multiple callbacks.","date":"2014-04-09T01:57:38.594Z","type":"message"}
{"nick":"tjfontaine","message":"yes, tcp doesn't really handle that for you, it's part of your application protocol","date":"2014-04-09T01:57:39.900Z","type":"message"}
{"nick":"tjfontaine","message":"ip has some of those semantics (describing the size of the packet) and tcp enforces that packets will be received in order","date":"2014-04-09T01:58:24.812Z","type":"message"}
{"nick":"tjfontaine","message":"but if you are abstracting data upon tcp, you will need to reconstruct that information on your own, through semantics you define","date":"2014-04-09T01:58:44.929Z","type":"message"}
{"nick":"tjfontaine","message":"http://en.wikipedia.org/wiki/OSI_model#Layer_7:_application_layer","date":"2014-04-09T02:00:00.089Z","type":"message"}
{"nick":"Dirkson","message":"It would be a lot easier if I could have access to a user data pointer in my receive TCP data function. Set it to be a pointer to a struct with information about what's going on. As-is, I think I need to make some sort of lookup table based on whatever value is in the uv_stream_t handed me?","date":"2014-04-09T02:00:52.835Z","type":"message"}
{"nick":"tjfontaine","message":"you can set data on the tcp connection","date":"2014-04-09T02:01:16.391Z","type":"message"}
{"nick":"Orborde","message":"Dirkson: Does uv_stream_t have some kind of \"void* userdata\" field?","date":"2014-04-09T02:01:36.047Z","type":"message"}
{"nick":"Orborde","message":"That's how C libraries usually do this sort of thing.","date":"2014-04-09T02:01:43.777Z","type":"message"}
{"nick":"tjfontaine","message":"yes it does","date":"2014-04-09T02:01:47.298Z","type":"message"}
{"nick":"tjfontaine","message":"->data","date":"2014-04-09T02:01:51.841Z","type":"message"}
{"nick":"Dirkson","message":"Huzzah! That'll solve it.","date":"2014-04-09T02:01:54.908Z","type":"message"}
{"nick":"Dirkson","message":"Still way damn messier than I expected from libuv :-/","date":"2014-04-09T02:03:10.421Z","type":"message"}
{"nick":"tjfontaine","message":"some of the api allows you to associated for *hint","date":"2014-04-09T02:03:46.214Z","type":"message"}
{"nick":"tjfontaine","message":"another solution is to wrap your tcp connection in a struct and use OFFSETOF","date":"2014-04-09T02:04:12.518Z","type":"message"}
{"nick":"Dirkson","message":"\"associated for *hint\" ?  I don't follow","date":"2014-04-09T02:04:34.148Z","type":"message"}
{"nick":"tjfontaine","message":"uv_something(foo, hint);","date":"2014-04-09T02:04:46.146Z","type":"message"}
{"nick":"Orborde","message":"In related news, C is a ridiculous language.","date":"2014-04-09T02:05:22.120Z","type":"message"}
{"nick":"Orborde","message":"Dirkson: This sort of crazy bookkeeping is why people often take the performance hit and use lots of threads.","date":"2014-04-09T02:05:51.979Z","type":"message"}
{"nick":"Orborde","message":"I think","date":"2014-04-09T02:06:02.321Z","type":"message"}
{"nick":"Orborde","message":"At least","date":"2014-04-09T02:06:04.745Z","type":"message"}
{"nick":"Orborde","message":"I'm willing to sacrifice 100x performance not to have to deal with this ;-)","date":"2014-04-09T02:06:16.911Z","type":"message"}
{"nick":"m76","reason":"Read error: Connection reset by peer","date":"2014-04-09T02:06:28.072Z","type":"quit"}
{"nick":"tjfontaine","message":"well in newer C or in apple land you can use blocks","date":"2014-04-09T02:06:30.245Z","type":"message"}
{"nick":"Orborde","message":"tjfontaine: blocks?","date":"2014-04-09T02:06:53.076Z","type":"message"}
{"nick":"tjfontaine","message":"http://en.wikipedia.org/wiki/Blocks_(C_language_extension)","date":"2014-04-09T02:07:12.805Z","type":"message"}
{"nick":"Orborde","message":"tjfontaine: Are these some kind of coroutine thing?","date":"2014-04-09T02:07:49.271Z","type":"message"}
{"nick":"brunkle","date":"2014-04-09T02:08:55.294Z","type":"join"}
{"nick":"Dirkson","message":"If I send a hunk of tcp data < 64kb long, is there any reason to expect it will arrive in two separate callbacks?","date":"2014-04-09T02:10:00.182Z","type":"message"}
{"nick":"Dirkson","message":"If it answer is \"Yes, the data can come in separate callbacks\", what is the size of data that /can't/ come in separate callbacks?","date":"2014-04-09T02:11:48.854Z","type":"message"}
{"nick":"Orborde","message":"Dirkson: betcha the answer is \"1 byte\" because of the potential for IP-level fragmentation","date":"2014-04-09T02:12:29.910Z","type":"message"}
{"nick":"mikolalysenko","reason":"Ping timeout: 240 seconds","date":"2014-04-09T02:13:06.424Z","type":"quit"}
{"nick":"thlorenz","reason":"Remote host closed the connection","date":"2014-04-09T02:15:10.462Z","type":"quit"}
{"nick":"thlorenz","date":"2014-04-09T02:15:44.279Z","type":"join"}
{"nick":"thlorenz","reason":"Ping timeout: 240 seconds","date":"2014-04-09T02:20:07.166Z","type":"quit"}
{"nick":"TooTallNate","reason":"Quit: [\"Textual IRC Client: www.textualapp.com\"]","date":"2014-04-09T02:22:29.852Z","type":"quit"}
{"nick":"brunkle","reason":"Quit: brunkle","date":"2014-04-09T02:23:43.576Z","type":"quit"}
{"nick":"brunkle","date":"2014-04-09T02:27:09.272Z","type":"join"}
{"nick":"brunkle","reason":"Quit: brunkle","date":"2014-04-09T02:42:09.140Z","type":"quit"}
{"nick":"stagas","reason":"Read error: Connection reset by peer","date":"2014-04-09T02:48:06.947Z","type":"quit"}
{"nick":"daviddias","date":"2014-04-09T02:51:18.484Z","type":"join"}
{"nick":"brson","reason":"Quit: leaving","date":"2014-04-09T02:53:27.204Z","type":"quit"}
{"nick":"brson","date":"2014-04-09T02:53:44.619Z","type":"join"}
{"nick":"calvinfo","date":"2014-04-09T02:54:06.309Z","type":"join"}
{"nick":"daviddias","reason":"Ping timeout: 246 seconds","date":"2014-04-09T02:55:20.502Z","type":"quit"}
{"nick":"Orborde","message":"saghul_: Can you verify the above?","date":"2014-04-09T02:56:07.587Z","type":"message"}
{"nick":"Orborde","message":"That libuv's TCP read handler callbacks could get called with arbitrarily small slices of incoming data, regardless of the size of the originating write() on the other end of the socket?","date":"2014-04-09T02:56:57.847Z","type":"message"}
{"nick":"paulfryz_","date":"2014-04-09T02:57:38.668Z","type":"join"}
{"nick":"calvinfo","reason":"Ping timeout: 240 seconds","date":"2014-04-09T02:58:18.177Z","type":"quit"}
{"nick":"paulfryz_","reason":"Ping timeout: 246 seconds","date":"2014-04-09T03:01:59.589Z","type":"quit"}
{"nick":"bradleymeck","reason":"Quit: bradleymeck","date":"2014-04-09T03:02:18.006Z","type":"quit"}
{"nick":"mikolalysenko","date":"2014-04-09T03:09:15.309Z","type":"join"}
{"nick":"Orborde","message":"Does libuv have a message-oriented transport protocol in it somewhere?","date":"2014-04-09T03:11:59.926Z","type":"message"}
{"nick":"Orborde","message":"That runs over TCP?","date":"2014-04-09T03:12:04.285Z","type":"message"}
{"nick":"mikolalysenko","reason":"Ping timeout: 240 seconds","date":"2014-04-09T03:13:58.178Z","type":"quit"}
{"nick":"rmg","reason":"Remote host closed the connection","date":"2014-04-09T03:30:11.986Z","type":"quit"}
