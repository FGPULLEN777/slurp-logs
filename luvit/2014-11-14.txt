{"nick":"dan336","reason":"Quit: Leaving.","date":"2014-11-14T00:02:28.571Z","type":"quit"}
{"nick":"cledev","date":"2014-11-14T01:11:05.348Z","type":"join"}
{"nick":"kazupon","date":"2014-11-14T01:51:25.579Z","type":"join"}
{"nick":"cledev","reason":"Ping timeout: 240 seconds","date":"2014-11-14T02:03:52.997Z","type":"quit"}
{"nick":"travis-ci","date":"2014-11-14T03:05:35.719Z","type":"join"}
{"nick":"travis-ci","message":"luvit/luvit#1157 (luvi-up - 2c30ee3 : Ryan Phillips): The build has errored.","date":"2014-11-14T03:05:35.945Z","type":"message"}
{"nick":"travis-ci","message":"Change view : https://github.com/luvit/luvit/compare/fffd678d23b9...2c30ee31b755","date":"2014-11-14T03:05:35.946Z","type":"message"}
{"nick":"travis-ci","message":"Build details : http://travis-ci.org/luvit/luvit/builds/40959305","date":"2014-11-14T03:05:35.946Z","type":"message"}
{"nick":"travis-ci","date":"2014-11-14T03:05:35.946Z","type":"part"}
{"nick":"rphillips","message":"creationix: https://gist.github.com/rphillips/e0a3258e8e37f6357acf","date":"2014-11-14T03:08:28.337Z","type":"message"}
{"nick":"rphillips","message":"this would be slick to have in luvi, but it will need zip creation support","date":"2014-11-14T03:09:04.245Z","type":"message"}
{"nick":"creationix","message":"rphillips: zip creation isn’t too bad, I can write it tomorrow if you wish","date":"2014-11-14T03:09:23.181Z","type":"message"}
{"nick":"travis-ci","date":"2014-11-14T03:09:36.944Z","type":"join"}
{"nick":"travis-ci","message":"luvit/luvit#1157 (luvi-up - 2c30ee3 : Ryan Phillips): The build passed.","date":"2014-11-14T03:09:37.133Z","type":"message"}
{"nick":"travis-ci","message":"Change view : https://github.com/luvit/luvit/compare/fffd678d23b9...2c30ee31b755","date":"2014-11-14T03:09:37.133Z","type":"message"}
{"nick":"travis-ci","message":"Build details : http://travis-ci.org/luvit/luvit/builds/40959305","date":"2014-11-14T03:09:37.133Z","type":"message"}
{"nick":"travis-ci","date":"2014-11-14T03:09:37.133Z","type":"part"}
{"nick":"rphillips","message":"creationix: that would rock","date":"2014-11-14T03:10:03.236Z","type":"message"}
{"nick":"creationix","message":"it’s something I’ve been wanting to add","date":"2014-11-14T03:10:14.583Z","type":"message"}
{"nick":"rphillips","message":"i would like a brain dump about the coroutine stuff","date":"2014-11-14T03:11:41.129Z","type":"message"}
{"nick":"creationix","message":"brain dump?","date":"2014-11-14T03:15:37.207Z","type":"message"}
{"nick":"creationix","message":"do you have questions?","date":"2014-11-14T03:15:47.620Z","type":"message"}
{"nick":"rphillips","message":"yeah, I don't get the chain logic yet","date":"2014-11-14T03:16:05.190Z","type":"message"}
{"nick":"creationix","message":"ahh, the protocol parsers","date":"2014-11-14T03:16:14.467Z","type":"message"}
{"nick":"creationix","message":"yeah, that took me a couple days to wrap my head around","date":"2014-11-14T03:16:22.820Z","type":"message"}
{"nick":"creationix","message":"I’d love some feedback on the chain syntax too.  I’m not settled on how it works","date":"2014-11-14T03:17:06.019Z","type":"message"}
{"nick":"creationix","message":"but the basic idea is that each segment in a chain runs as an independent coroutine","date":"2014-11-14T03:17:20.022Z","type":"message"}
{"nick":"creationix","message":"it can read from it’s source and write to it’s destination","date":"2014-11-14T03:17:29.398Z","type":"message"}
{"nick":"creationix","message":"both read and write are blocking","date":"2014-11-14T03:17:34.606Z","type":"message"}
{"nick":"creationix","message":"since lua is single threaded, only one of the coroutines will run at a time, most will be blocked on reading or writing most of the time","date":"2014-11-14T03:18:14.914Z","type":"message"}
{"nick":"creationix","message":"chain basically takes a list of workers and moves data between them","date":"2014-11-14T03:18:38.189Z","type":"message"}
{"nick":"creationix","message":"suppose I have workers 1, 2, and 3.  1’s read is the real external read, say from a tcp socket, 3’s write is also to the tcp socket","date":"2014-11-14T03:19:08.541Z","type":"message"}
{"nick":"creationix","message":"when 1 writes, it will check if 2 is waiting for the data, if it is, it will resume 2 passing the data along.  Then 1 will be blocked till 2 yields","date":"2014-11-14T03:19:49.453Z","type":"message"}
{"nick":"creationix","message":"if 1 writes and 2 isn’t waiting to read yet, then 1 will yield and wait for a reader","date":"2014-11-14T03:20:04.714Z","type":"message"}
{"nick":"creationix","message":"when 2 reads, if there is no data waiting in 1, it will yield","date":"2014-11-14T03:20:24.543Z","type":"message"}
{"nick":"rphillips","message":"it could potentially deadlock, right?","date":"2014-11-14T03:21:36.439Z","type":"message"}
{"nick":"creationix","message":"if there is data, 2 will take the data from the box, resume 1 (and wait for 1 to yield again) and then return","date":"2014-11-14T03:21:41.921Z","type":"message"}
{"nick":"creationix","message":"deadlock isn’t too likely here","date":"2014-11-14T03:22:15.486Z","type":"message"}
{"nick":"creationix","message":"that last case was https://github.com/luvit/luvit/blob/luvi-up/app/modules/codec.lua#L100-L105","date":"2014-11-14T03:22:21.919Z","type":"message"}
{"nick":"creationix","message":"I had to look it up","date":"2014-11-14T03:22:26.338Z","type":"message"}
{"nick":"creationix","message":"resume is always a non-blocking operation","date":"2014-11-14T03:22:48.096Z","type":"message"}
{"nick":"creationix","message":"so when 2 resumes 1 after taking the data from 1’s box, it will return soon","date":"2014-11-14T03:23:05.033Z","type":"message"}
{"nick":"creationix","message":"most of the time, 1 will loop around and read from it’s source causing it to yield","date":"2014-11-14T03:23:21.893Z","type":"message"}
{"nick":"creationix","message":"since each segment is it’s own coroutine and only one can run at a time, blocking in one coroutine is what enables the others to continue","date":"2014-11-14T03:24:55.532Z","type":"message"}
{"nick":"creationix","message":"typically all the segments are waiting on read (except in the base of backpressure)","date":"2014-11-14T03:26:19.443Z","type":"message"}
{"nick":"creationix","message":"so 1 gets data, writes to 2 who is waiting, who writes to 3 who is waiting, who writes to the socket, the kernel buffer has room, 3 then blocks on read, returns to 2 who loops back and blocks on read, returns and 1 loops back to blocking on read from the tcp socket","date":"2014-11-14T03:27:14.781Z","type":"message"}
{"nick":"creationix","message":"if there is backpressure, they tend to all get blocked on writing","date":"2014-11-14T03:27:42.189Z","type":"message"}
{"nick":"creationix","message":"I use nil to signal end of stream","date":"2014-11-14T03:28:12.465Z","type":"message"}
{"nick":"rphillips","message":"so a chain from 1,2,3, will potentially run in the same tick","date":"2014-11-14T03:28:13.376Z","type":"message"}
{"nick":"creationix","message":"right, if the codecs are purely CPU transforms (like http and tls)","date":"2014-11-14T03:28:30.377Z","type":"message"}
{"nick":"rphillips","message":"but if one is waiting then it pauses","date":"2014-11-14T03:28:30.789Z","type":"message"}
{"nick":"creationix","message":"so most codec loops look like `for item in read() do write(item) end ; write()`","date":"2014-11-14T03:29:14.685Z","type":"message"}
{"nick":"creationix","message":"with some extra logic in the middle","date":"2014-11-14T03:29:21.191Z","type":"message"}
{"nick":"creationix","message":"for..in will exit when read returns nil, and the final write will forward the nil","date":"2014-11-14T03:29:39.403Z","type":"message"}
{"nick":"rphillips","message":"that helps a lot","date":"2014-11-14T03:31:48.794Z","type":"message"}
{"nick":"creationix","message":"I was worried about performance, that’s why a benchmark was the first thing I did","date":"2014-11-14T03:32:35.260Z","type":"message"}
{"nick":"creationix","message":"but I get around 100k/sec with 3 workers + the wrapped tcp socket","date":"2014-11-14T03:32:51.630Z","type":"message"}
{"nick":"rphillips","message":"http?","date":"2014-11-14T03:33:05.427Z","type":"message"}
{"nick":"creationix","message":"the 3 workers are httpServerDecode, app, and httpServerEncode","date":"2014-11-14T03:33:09.084Z","type":"message"}
{"nick":"creationix","message":"with tls it’s 5","date":"2014-11-14T03:33:14.579Z","type":"message"}
{"nick":"creationix","message":"tls-decode, http-decode, app, http-encode, tls-encode","date":"2014-11-14T03:33:28.574Z","type":"message"}
{"nick":"creationix","message":"the tls encode and decode pair need to be made together sinde handshake bypasses the inner layers","date":"2014-11-14T03:33:54.363Z","type":"message"}
{"nick":"creationix","message":"that why it returned a function instead of just exporting encode/decode","date":"2014-11-14T03:34:08.293Z","type":"message"}
{"nick":"creationix","message":"the tls code came out really elegant with handshake being one loop https://github.com/luvit/luvit/blob/tls-codec/app/modules/codecs/tls.lua#L40-L53","date":"2014-11-14T03:34:57.486Z","type":"message"}
{"nick":"kazupon","reason":"Remote host closed the connection","date":"2014-11-14T03:35:00.739Z","type":"quit"}
{"nick":"creationix","message":"and then two simple workers to feed the data through the ssl context","date":"2014-11-14T03:35:17.162Z","type":"message"}
{"nick":"creationix","message":"I don’t assume which of tls.encoder or tls.decoder get called first, so I just yield the first, and then handshake in the second","date":"2014-11-14T03:36:23.777Z","type":"message"}
{"nick":"creationix","message":"in this case it’s encoder that gets started first since that’s the order in chain","date":"2014-11-14T03:36:44.396Z","type":"message"}
{"nick":"creationix","message":"*decoder","date":"2014-11-14T03:36:48.614Z","type":"message"}
{"nick":"creationix","message":"https://github.com/luvit/luvit/blob/tls-codec/tests/test-tls-codec.lua#L52","date":"2014-11-14T03:37:09.699Z","type":"message"}
{"nick":"rphillips","message":"that is slick","date":"2014-11-14T03:48:32.638Z","type":"message"}
{"nick":"rphillips","message":"chain(resolver.decode, app, resolver.encode)","date":"2014-11-14T03:51:48.265Z","type":"message"}
{"nick":"rphillips","message":"is that correct?","date":"2014-11-14T03:52:03.910Z","type":"message"}
{"nick":"creationix","message":"chain returns a function that takes read and write","date":"2014-11-14T03:52:53.410Z","type":"message"}
{"nick":"creationix","message":"wrapStream creates a blocking read,write pair from a uv_stream_t","date":"2014-11-14T03:53:06.438Z","type":"message"}
{"nick":"creationix","message":"this is the part I’m considering changing, chain is kinda strange","date":"2014-11-14T03:53:25.037Z","type":"message"}
{"nick":"creationix","message":"we could make a chaining API","date":"2014-11-14T03:54:41.436Z","type":"message"}
{"nick":"creationix","message":"wrap(socket):add(tls):add(http):run(app)","date":"2014-11-14T03:55:08.546Z","type":"message"}
{"nick":"creationix","message":"and add would assume the thing to the left was upstream and .decode from it and .encode on the way out","date":"2014-11-14T03:55:25.267Z","type":"message"}
{"nick":"creationix","message":"conceptually though, chain is much simpler","date":"2014-11-14T03:56:14.486Z","type":"message"}
{"nick":"creationix","message":"it takes several (read,write) workers and creates a new composite worker","date":"2014-11-14T03:56:29.846Z","type":"message"}
{"nick":"creationix","message":"worker concatenation","date":"2014-11-14T03:56:43.804Z","type":"message"}
{"nick":"creationix","message":"and with chain, I suppose you could work wither direction","date":"2014-11-14T03:57:48.134Z","type":"message"}
{"nick":"creationix","message":"we would just need a version of wrapStream that accepted read,write instead of producing it","date":"2014-11-14T03:58:31.913Z","type":"message"}
{"nick":"creationix","message":"and the app would need to produce those instead of accepting them","date":"2014-11-14T03:58:51.310Z","type":"message"}
{"nick":"creationix","message":"hmm, that seems backwards, probably not a good idea","date":"2014-11-14T03:59:00.354Z","type":"message"}
{"nick":"creationix","message":"chain(http.encode, wrapSocket(socket), http.decode)(app())","date":"2014-11-14T04:01:02.069Z","type":"message"}
{"nick":"travis-ci","date":"2014-11-14T04:03:56.267Z","type":"join"}
{"nick":"travis-ci","message":"luvit/luvit#1158 (luvi-up - 5bb5137 : Tim Caswell): The build passed.","date":"2014-11-14T04:03:56.493Z","type":"message"}
{"nick":"travis-ci","message":"Change view : https://github.com/luvit/luvit/compare/2c30ee31b755...5bb5137f029a","date":"2014-11-14T04:03:56.493Z","type":"message"}
{"nick":"travis-ci","message":"Build details : http://travis-ci.org/luvit/luvit/builds/40962281","date":"2014-11-14T04:03:56.493Z","type":"message"}
{"nick":"travis-ci","date":"2014-11-14T04:03:56.494Z","type":"part"}
{"nick":"kazupon","date":"2014-11-14T04:25:45.357Z","type":"join"}
{"nick":"ra_","date":"2014-11-14T04:48:16.205Z","type":"join"}
{"nick":"ra^^","reason":"Ping timeout: 240 seconds","date":"2014-11-14T04:50:17.252Z","type":"quit"}
{"nick":"kazupon","reason":"Remote host closed the connection","date":"2014-11-14T06:46:37.496Z","type":"quit"}
{"nick":"kazupon","date":"2014-11-14T07:01:27.324Z","type":"join"}
